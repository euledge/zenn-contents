---
title: "RDBでスキーマレスな柔軟性を！型安全なEAVパターンの設計と実装"
emoji: "🏗️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["architecture", "database", "java", "sql"]
published: false
---

# はじめに

システムを開発・運用していると、避けて通れないのが「拠点や品目ごとに、ちょっとだけ管理したい項目が違う」という問題です。

* 「食品倉庫（拠点A）では『賞味期限』が必須だが、アパレル倉庫（拠点B）では不要」
* 「特定の品目だけに『洗濯表示』や『素材構成』などのメタ情報を追加したいが、テーブル定義（DDL）を変えてリリースするのは時間がかかる……」

こうした課題を解決する手法として、**EAV（Entity-Attribute-Value）パターン**があります。しかし、EAVは「何でも文字列で保存してしまい、型安全性が失われる」という理由から、一種のアンチパターンとして扱われることもあります。

本記事では、在庫管理システムを例に、**DBレベルでの型安全と整合性を保ちつつ、柔軟性を確保する「型安全なEAV」**の設計と実装例をご紹介します。

---

## 1. 課題：テーブル定義変更のコストをどう下げるか？

在庫管理などの現場では、拠点（倉庫）や扱う品目カテゴリごとに管理項目が微妙に異なることがよくあります。
そのたびにテーブルを拡張し、アプリケーションを再ビルド・再デプロイするのはコストが高く、柔軟性に欠けます。

そこで、**「スキーマを変更することなく、動的に属性を追加・管理できる」**というEAVのメリットを、RDBの堅牢性を損なわずに取り入れることを目指しました。

---

## 2. DB設計の工夫：共通テーブルと型安全なEAVテーブル

全ての在庫品目で共通して必要な項目（基幹属性）は通常のテーブルに定義し、拠点やカテゴリごとに異なる項目のみをEAVテーブルで管理します。

### ベースとなる在庫テーブル
入庫日時や出庫予定日時などは、どの倉庫でも共通の項目として定義します。

```sql
CREATE TABLE inventory_item (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    item_name VARCHAR(255) NOT NULL,
    arrival_date_time DATETIME NOT NULL,          -- 入庫日時（共通）
    scheduled_departure_date_time DATETIME,       -- 出庫予定日時（共通）
    warehouse_type VARCHAR(20) NOT NULL           -- 'FOOD', 'APPAREL' など
);
```

### 個別属性テーブル (EAV)
共通テーブルでは持ちきれない属性のみをこちらに切り出します。

### MySQLでの実装例
（※注意：`CHECK` 制約が実際に機能するのは MySQL 8.0.16 以降です）

```sql
CREATE TABLE inventory_item_attribute (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    inventory_item_id BIGINT NOT NULL, -- inventory_item への外部キー
    attribute_name VARCHAR(255) NOT NULL,

    -- どの型として扱うかを指定
    value_type ENUM('STRING','NUMBER','DATE','DATETIME','BOOLEAN') NOT NULL,
    
    -- 型ごとにカラムを分ける
    attribute_value_string VARCHAR(255),
    attribute_value_number DECIMAL(10,3),
    attribute_value_date DATE,
    attribute_value_datetime DATETIME,
    attribute_value_boolean BOOLEAN,

    -- 【重要】CHECK制約による整合性の保証
    CONSTRAINT chk_attribute_consistency CHECK (
        (value_type = 'STRING'   AND attribute_value_string IS NOT NULL AND attribute_value_number IS NULL) OR
        (value_type = 'NUMBER'   AND attribute_value_number IS NOT NULL AND attribute_value_string IS NULL) OR
        -- ...
    ),
    FOREIGN KEY (inventory_item_id) REFERENCES inventory_item(id)
);
```

### PostgreSQL / 標準SQL準拠の実装例（ポータブル）
他のDB（PostgreSQL, SQL Server, Oracleなど）への移植性を考慮する場合は、標準SQLの `IDENTITY` 構文や `CHECK` 制約を組み合わせて、特定のDBベンダーに依存しない形で定義します。

```sql
CREATE TABLE inventory_item_attribute (
    -- 標準SQL準拠の自動採番
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    inventory_item_id BIGINT NOT NULL,
    attribute_name VARCHAR(255) NOT NULL,

    -- ENUMの代わりにVARCHAR + CHECK制約を使用
    value_type VARCHAR(20) NOT NULL,
    
    attribute_value_string VARCHAR(255),
    attribute_value_number DECIMAL(10,3),
    attribute_value_date DATE,
    attribute_value_datetime TIMESTAMP, -- 汎用的な時間型
    attribute_value_boolean BOOLEAN,

    -- 値の種類の制限
    CONSTRAINT chk_value_type CHECK (value_type IN ('STRING','NUMBER','DATE','DATETIME','BOOLEAN')),
    
    -- 整合性の保証（MySQL版と同様のロジック）
    CONSTRAINT chk_attribute_consistency CHECK (
        (value_type = 'STRING' AND attribute_value_string IS NOT NULL AND attribute_value_number IS NULL) OR
        -- ...
    )
);
```

### この設計のメリット
1.  **型安全**: 数値や日付を適切なデータ型で保存できるため、DBのインデックスが効き、範囲検索なども効率的です。
2.  **整合性**: `CHECK` 制約により、「型は数値なのに、文字列カラムに値が入っている」といった矛盾した状態をDB層で完全に防げます。
3.  **検索性**: 型が分かれているため、特定の型に絞ったクエリが書きやすくなります。

---

## 3. 実装の構造：ドメイン層を汚さない

DBが特殊な構造（EAV）をしているからといって、アプリケーションのビジネスロジックまでそれを意識するのは避けたいところです。

### 3.1. インフラ層 (DTO / Entity)
JPAなどで扱う際は、型別のカラムを `@Embedded` でまとめたり、基底クラスを活用して共通化します。

### 3.2. ドメイン層への抽象化
ドメイン層では、技術的なEAV構造を隠蔽するために、**Sealed Interface** と実装クラスを活用します。属性へのアクセスを専用のクラスにカプセル化することで、利用側は型安全に値を扱えます。

```java
public sealed interface AttributeValue {
    record StringValue(String value) implements AttributeValue {}
    record NumberValue(BigDecimal value) implements AttributeValue {}
    record DateValue(LocalDate value) implements AttributeValue {}
    record DateTimeValue(LocalDateTime value) implements AttributeValue {}
    record BooleanValue(Boolean value) implements AttributeValue {}
}

// 動的属性のベースインタフェース
public interface ExpandAttribute {
    Map<String, AttributeValue> toMap();
}

// 食品倉庫用の属性クラス
public record FoodInventoryAttribute(Map<String, AttributeValue> values) implements ExpandAttribute {
    @Override public Map<String, AttributeValue> toMap() { return values; }

    public Optional<LocalDate> expiryDate() {
        return Optional.ofNullable(values.get("EXPIRY_DATE"))
            .filter(v -> v instanceof AttributeValue.DateValue)
            .map(v -> ((AttributeValue.DateValue) v).value());
    }
}

// アパレル倉庫用の属性クラス
public record ApparelInventoryAttribute(Map<String, AttributeValue> values) implements ExpandAttribute {
    @Override public Map<String, AttributeValue> toMap() { return values; }

    public Optional<String> material() {
        return Optional.ofNullable(values.get("MATERIAL"))
            .filter(v -> v instanceof AttributeValue.StringValue)
            .map(v -> ((AttributeValue.StringValue) v).value());
    }
}
```

### 3.3. マッピング処理
DBから取得したデータを、倉庫種別（`warehouse_type`）に応じて適切な属性クラスにマッピングします。

```java
public static InventoryItem<? extends ExpandAttribute> toDomain(
        InventoryItemDto itemDto, 
        List<InventoryItemAttributeDto> attrDtos) {
    
    // 属性リストをMapに変換
    Map<String, AttributeValue> values = attrDtos.stream()
        .collect(Collectors.toMap(
            InventoryItemAttributeDto::getAttributeName,
            dto -> mapToValue(dto) // 前述のswitch式による型変換
        ));

    // 倉庫種別に応じて属性クラスを切り替え
    ExpandAttribute attributes = switch (itemDto.getWarehouseType()) {
        case "FOOD"    -> new FoodInventoryAttribute(values);
        case "APPAREL" -> new ApparelInventoryAttribute(values);
        default        -> throw new IllegalArgumentException();
    };

    return new InventoryItem<>(
        itemDto.getId(),
        itemDto.getItemName(),
        itemDto.getArrivalDateTime(),
        itemDto.getScheduledDepartureDateTime(),
        attributes
    );
}
```

### 3.4. 共通エンティティ `InventoryItem`
全ての在庫品目に共通する項目は `InventoryItem` クラスで保持し、動的属性の部分をジェネリクスで抽象化します。

```java
public record InventoryItem<T extends ExpandAttribute>(
    Long id,
    String itemName,
    LocalDateTime arrivalDateTime,
    LocalDateTime scheduledDepartureDateTime,
    T attributes // 具象属性クラス（FoodInventoryAttributeなど）が入る
) {
    public String summary() {
        return String.format("[%d] %s (入庫: %s, 属性数: %d)", 
            id, itemName, arrivalDateTime, attributes.toMap().size());
    }
}
```

### 3.5. 利用例：型安全な属性アクセス
この構成により、共通の在庫管理ロジックと、倉庫固有の属性操作を両立できます。

```java
public class InventoryManagementService {
    public void processFoodItem(InventoryItem<FoodInventoryAttribute> foodItem) {
        System.out.println(foodItem.summary());
        
        // 属性クラスのメソッドを通じて、型安全にアクセス可能
        foodItem.attributes().expiryDate().ifPresent(date -> {
            if (date.isBefore(LocalDate.now())) {
                System.out.println("警告：期限切れです！");
            }
        });
    }

    public void processApparelItem(InventoryItem<ApparelInventoryAttribute> apparelItem) {
        System.out.println(apparelItem.summary());
        
        // アパレル固有の属性（素材）にアクセス
        apparelItem.attributes().material().ifPresent(m -> 
            System.out.println("素材: " + m));
    }
}
```

---

## 4. まとめ

EAVパターンは諸刃の剣ですが、以下の工夫を凝らすことで非常に強力な武器になります。

*   **DB層**: MySQLの独自機能や、標準SQLの `CHECK` 制約を使い、型ごとにカラムを分けて整合性を担保する。
*   **アプリ層**: インターフェースとマッパーを活用し、ビジネスロジックからEAVの構造を隔離する。

「RDBの堅牢さ」と「スキーマレスな柔軟性」を両立させたい時の選択肢として、ぜひ検討してみてください。
